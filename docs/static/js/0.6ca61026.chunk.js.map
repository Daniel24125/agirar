{"version":3,"sources":["../node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator/index.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","../../src/utils.js","../../src/config.js","../../src/queryCache.js","../../src/setFocusHandler.js","../../src/useBaseQuery.js","../../src/useQuery.js","../node_modules/regenerator-runtime/runtime.js"],"names":["module","exports","asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","_asyncToGenerator","fn","self","this","args","arguments","apply","err","undefined","_uid","uid","cancelledError","isServer","window","noop","Console","console","warn","log","functionalUpdate","updater","old","stableStringifyReplacer","_","isObject","Object","a","Array","isDocumentVisible","document","getQueryArgs","queryKey","queryFn","Error","config","rest","useMountedCallback","callback","mounted","React","handleSuspense","queryInfo","setTimeout","configContext","DEFAULTS","shared","suspense","queryKeySerializerFn","invalidQueryKey","d","queryHash","obj","JSON","queries","enabled","retry","retryDelay","attemptIndex","Math","staleTime","cacheTime","refetchOnWindowFocus","refetchInterval","queryFnParamsFilter","refetchOnMount","isDataEqual","deepEqual","b","length","i","keys","onError","onSuccess","onSettled","useErrorBoundary","mutations","throwOnError","onMutate","defaultConfigRef","current","useConfigContext","subscribe","result","body","recover","f","queryCache","makeQueryCache","queryCacheContext","queryCaches","useQueryCache","frozen","defaultConfig","globalListeners","configRef","isFetching","notifyGlobalListeners","query","acc","cb","notify","exact","predicate","deepIncludes","refetchActive","initialData","hasInitialData","isStale","initialStatus","instances","state","queryReducer","type","action","clearTimeout","instance","onStateUpdate","id","clearInterval","oldConfig","minInterval","setInterval","tryFetchData","promise","delay","__queryFn","callbackInstances","cancelled","makeQuery","force","newState","status","canFetchMore","failureCount","markedForGarbageCollection","data","updatedAt","Date","switchActions","isLoading","isSuccess","isError","isIdle","onWindowFocus","navigator","handleFocus","removePreviousHandler","useBaseQuery","rerender","instanceRef","refetch","useQuery","runtime","Op","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","wrap","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","create","context","Context","_invoke","method","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","makeInvokeMethod","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","invoke","__await","unwrapped","TypeError","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","iter","toString","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function"],"mappings":"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","file":"static/js/0.6ca61026.chunk.js","sourcesContent":["module.exports = require(\"regenerator-runtime\");\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}","import React from 'react'\n\n//\n\nexport const statusIdle = 'idle'\nexport const statusLoading = 'loading'\nexport const statusError = 'error'\nexport const statusSuccess = 'success'\n\nlet _uid = 0\nexport const uid = () => _uid++\nexport const cancelledError = {}\nexport let globalStateListeners = []\nexport const isServer = typeof window === 'undefined'\nexport const noop = () => {}\nexport const identity = d => d\nexport let Console = console || { error: noop, warn: noop, log: noop }\n\nexport function useUid() {\n  const ref = React.useRef(null)\n\n  if (ref.current === null) {\n    ref.current = uid()\n  }\n\n  return ref.current\n}\n\nexport function setConsole(c) {\n  Console = c\n}\n\nexport function useGetLatest(obj) {\n  const ref = React.useRef()\n  ref.current = obj\n\n  return React.useCallback(() => ref.current, [])\n}\n\nexport function functionalUpdate(updater, old) {\n  return typeof updater === 'function' ? updater(old) : updater\n}\n\nexport function stableStringifyReplacer(_, value) {\n  return isObject(value)\n    ? Object.assign(\n        {},\n        ...Object.keys(value)\n          .sort()\n          .map(key => ({\n            [key]: value[key],\n          }))\n      )\n    : value\n}\n\nexport function stableStringify(obj) {\n  return JSON.stringify(obj, stableStringifyReplacer)\n}\n\nexport function isObject(a) {\n  return a && typeof a === 'object' && !Array.isArray(a)\n}\n\nexport function deepIncludes(a, b) {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(key => !deepIncludes(a[key], b[key]))\n  }\n\n  return false\n}\n\nexport function isDocumentVisible() {\n  return (\n    typeof document === 'undefined' ||\n    document.visibilityState === undefined ||\n    document.visibilityState === 'visible' ||\n    document.visibilityState === 'prerender'\n  )\n}\n\nexport function isOnline() {\n  return navigator.onLine === undefined || navigator.onLine\n}\n\nexport function getQueryArgs(args) {\n  if (isObject(args[0])) {\n    if (\n      args[0].hasOwnProperty('queryKey') &&\n      args[0].hasOwnProperty('queryFn')\n    ) {\n      const { queryKey, queryFn, config = {} } = args[0]\n      return [queryKey, queryFn, config, ...args.slice(1)]\n    } else {\n      throw new Error('queryKey and queryFn keys are required.')\n    }\n  }\n\n  const [queryKey, queryFn, config = {}, ...rest] = args\n\n  return [queryKey, queryFn, config, ...rest]\n}\n\nexport function useMountedCallback(callback) {\n  const mounted = React.useRef(false)\n\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mounted.current = true\n    return () => (mounted.current = false)\n  }, [])\n\n  return React.useCallback(\n    (...args) => (mounted.current ? callback(...args) : void 0),\n    [callback]\n  )\n}\n\nexport function handleSuspense(queryInfo) {\n  if (\n    queryInfo.query.config.suspense ||\n    queryInfo.query.config.useErrorBoundary\n  ) {\n    if (queryInfo.query.state.status === statusError) {\n      if (!queryInfo.query.suspenseErrorHandled) {\n        queryInfo.query.suspenseErrorHandled = true\n\n        setTimeout(() => {\n          queryInfo.query.state.status = statusLoading\n        }, 0)\n\n        throw queryInfo.error\n      }\n    }\n\n    queryInfo.query.suspenseErrorHandled = false\n\n    if (queryInfo.query.config.suspense && queryInfo.status === statusLoading) {\n      queryInfo.query.wasSuspended = true\n      throw queryInfo.query.fetch()\n    }\n  }\n}\n\n// This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.\n// The parts for comparing any non-JSON-supported values has been removed\nexport function deepEqual(a, b) {\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var length, i, keys\n    if (Array.isArray(a)) {\n      length = a.length\n      // eslint-disable-next-line eqeqeq\n      if (length != b.length) return false\n      for (i = length; i-- !== 0; ) if (!deepEqual(a[i], b[i])) return false\n      return true\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf()\n\n    keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    for (i = length; i-- !== 0; ) {\n      var key = keys[i]\n\n      if (!deepEqual(a[key], b[key])) return false\n    }\n\n    return true\n  }\n\n  // true if both NaN, false otherwise\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n","import React from 'react'\nimport { noop, stableStringify, identity, deepEqual } from './utils'\n\nexport const configContext = React.createContext()\n\nconst DEFAULTS = {\n  shared: {\n    suspense: false,\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n  },\n  queries: {\n    enabled: true,\n    retry: 3,\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n    staleTime: 0,\n    cacheTime: 5 * 60 * 1000,\n    refetchOnWindowFocus: true,\n    refetchInterval: false,\n    queryFnParamsFilter: identity,\n    refetchOnMount: true,\n    isDataEqual: deepEqual,\n    onError: noop,\n    onSuccess: noop,\n    onSettled: noop,\n    useErrorBoundary: false,\n  },\n  mutations: {\n    throwOnError: false,\n    onMutate: noop,\n    onError: noop,\n    onSuccess: noop,\n    onSettled: noop,\n    useErrorBoundary: false,\n  },\n}\n\nexport const defaultConfigRef = {\n  current: DEFAULTS,\n}\n\nexport function useConfigContext() {\n  return React.useContext(configContext) || defaultConfigRef.current\n}\n\nexport function ReactQueryConfigProvider({ config, children }) {\n  let configContextValue = useConfigContext()\n\n  const newConfig = React.useMemo(() => {\n    const { shared = {}, queries = {}, mutations = {} } = config\n    const {\n      shared: contextShared = {},\n      queries: contextQueries = {},\n      mutations: contextMutations = {},\n    } = configContextValue\n    return {\n      shared: {\n        ...contextShared,\n        ...shared,\n      },\n      queries: {\n        ...contextQueries,\n        ...queries,\n      },\n      mutations: {\n        ...contextMutations,\n        ...mutations,\n      },\n    }\n  }, [config, configContextValue])\n\n  React.useEffect(() => {\n    // restore previous config on unmount\n    return () => {\n      defaultConfigRef.current = { ...(configContextValue || DEFAULTS) }\n    }\n  }, [configContextValue])\n\n  if (!configContextValue) {\n    defaultConfigRef.current = newConfig\n  }\n\n  return (\n    <configContext.Provider value={newConfig}>\n      {children}\n    </configContext.Provider>\n  )\n}\n\nfunction invalidQueryKey() {\n  throw new Error('A valid query key is required!')\n}\n\nexport function defaultQueryKeySerializerFn(queryKey) {\n  if (!queryKey) {\n    invalidQueryKey()\n  }\n\n  if (!Array.isArray(queryKey)) {\n    queryKey = [queryKey]\n  }\n\n  if (queryKey.some(d => typeof d === 'function')) {\n    invalidQueryKey()\n  }\n\n  const queryHash = stableStringify(queryKey)\n  queryKey = JSON.parse(queryHash)\n\n  if (!queryHash) {\n    invalidQueryKey()\n  }\n\n  return [queryHash, queryKey]\n}\n","import React from 'react'\nimport {\n  isServer,\n  functionalUpdate,\n  cancelledError,\n  isDocumentVisible,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  getQueryArgs,\n  deepIncludes,\n  noop,\n  uid,\n  statusIdle,\n  Console,\n} from './utils'\nimport { defaultConfigRef } from './config'\n\nexport const queryCache = makeQueryCache()\n\nexport const queryCacheContext = React.createContext(queryCache)\n\nexport const queryCaches = [queryCache]\n\nexport const useQueryCache = () => React.useContext(queryCacheContext)\n\nexport function ReactQueryCacheProvider({ queryCache, children }) {\n  const resolvedQueryCache = React.useMemo(\n    () => queryCache || makeQueryCache(),\n    [queryCache]\n  )\n\n  React.useEffect(() => {\n    queryCaches.push(resolvedQueryCache)\n\n    return () => {\n      // remove the cache from the active list\n      const i = queryCaches.indexOf(resolvedQueryCache)\n      if (i > -1) {\n        queryCaches.splice(i, 1)\n      }\n      // if the resolvedQueryCache was created by us, we need to tear it down\n      if (queryCache == null) {\n        resolvedQueryCache.clear()\n      }\n    }\n  }, [resolvedQueryCache, queryCache])\n\n  return (\n    <queryCacheContext.Provider value={resolvedQueryCache}>\n      {children}\n    </queryCacheContext.Provider>\n  )\n}\n\nconst actionInit = 'Init'\nconst actionFailed = 'Failed'\nconst actionMarkStale = 'MarkStale'\nconst actionMarkGC = 'MarkGC'\nconst actionFetch = 'Fetch'\nconst actionSuccess = 'Success'\nconst actionError = 'Error'\nconst actionSetState = 'SetState'\n\nexport function makeQueryCache({ frozen = isServer, defaultConfig } = {}) {\n  // A frozen cache does not add new queries to the cache\n  const globalListeners = []\n\n  const configRef = defaultConfig\n    ? { current: defaultConfig }\n    : defaultConfigRef\n\n  const queryCache = {\n    queries: {},\n    isFetching: 0,\n  }\n\n  const notifyGlobalListeners = () => {\n    queryCache.isFetching = Object.values(queryCache.queries).reduce(\n      (acc, query) => (query.state.isFetching ? acc + 1 : acc),\n      0\n    )\n\n    globalListeners.forEach(d => d(queryCache))\n  }\n\n  queryCache.subscribe = cb => {\n    globalListeners.push(cb)\n    return () => {\n      globalListeners.splice(globalListeners.indexOf(cb), 1)\n    }\n  }\n\n  queryCache.clear = ({ notify = true } = {}) => {\n    Object.values(queryCache.queries).forEach(query => query.clear())\n    queryCache.queries = {}\n    if (notify) {\n      notifyGlobalListeners()\n    }\n  }\n\n  queryCache.getQueries = (predicate, { exact } = {}) => {\n    if (predicate === true) {\n      return Object.values(queryCache.queries)\n    }\n\n    if (typeof predicate !== 'function') {\n      const [\n        queryHash,\n        queryKey,\n      ] = configRef.current.shared.queryKeySerializerFn(predicate)\n\n      predicate = d =>\n        exact ? d.queryHash === queryHash : deepIncludes(d.queryKey, queryKey)\n    }\n\n    return Object.values(queryCache.queries).filter(predicate)\n  }\n\n  queryCache.getQuery = queryKey =>\n    queryCache.getQueries(queryKey, { exact: true })[0]\n\n  queryCache.getQueryData = queryKey =>\n    queryCache.getQuery(queryKey)?.state.data\n\n  queryCache.removeQueries = (...args) => {\n    queryCache.getQueries(...args).forEach(query => query.clear())\n  }\n\n  queryCache.cancelQueries = (...args) => {\n    queryCache.getQueries(...args).forEach(query => query.cancel())\n  }\n\n  queryCache.invalidateQueries = async (\n    predicate,\n    { refetchActive = true, exact, throwOnError } = {}\n  ) => {\n    try {\n      return await Promise.all(\n        queryCache.getQueries(predicate, { exact }).map(query => {\n          if (refetchActive && query.instances.length) {\n            return query.fetch()\n          }\n\n          return query.invalidate()\n        })\n      )\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  queryCache.buildQuery = (userQueryKey, queryFn, config = {}) => {\n    config = {\n      ...configRef.current.shared,\n      ...configRef.current.queries,\n      ...config,\n    }\n\n    let [queryHash, queryKey] = config.queryKeySerializerFn(userQueryKey)\n\n    let query = queryCache.queries[queryHash]\n\n    if (query) {\n      Object.assign(query, { queryFn, config })\n    } else {\n      query = makeQuery({\n        queryCache,\n        queryKey,\n        queryHash,\n        queryFn,\n        config,\n      })\n\n      // If the query started with data, schedule\n      // a stale timeout\n      if (!isServer && query.state.data) {\n        query.scheduleStaleTimeout()\n\n        // Simulate a query healing process\n        query.heal()\n        // Schedule for garbage collection in case\n        // nothing subscribes to this query\n        query.scheduleGarbageCollection()\n      }\n\n      if (!frozen) {\n        queryCache.queries[queryHash] = query\n\n        if (isServer) {\n          notifyGlobalListeners()\n        } else {\n          // Here, we setTimeout so as to not trigger\n          // any setState's in parent components in the\n          // middle of the render phase.\n          setTimeout(() => {\n            notifyGlobalListeners()\n          })\n        }\n      }\n    }\n\n    query.fallbackInstance = {\n      config: {\n        onSuccess: query.config.onSuccess,\n        onError: query.config.onError,\n        onSettled: query.config.onSettled,\n      },\n    }\n\n    return query\n  }\n\n  queryCache.prefetchQuery = async (...args) => {\n    let [\n      queryKey,\n      queryFn,\n      config,\n      { force, throwOnError } = {},\n    ] = getQueryArgs(args)\n\n    try {\n      const query = queryCache.buildQuery(queryKey, queryFn, config)\n      if (force || query.state.isStale) {\n        await query.fetch()\n      }\n      return query.state.data\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  queryCache.setQueryData = (queryKey, updater, config = {}) => {\n    let query = queryCache.getQuery(queryKey)\n\n    if (!query) {\n      query = queryCache.buildQuery(queryKey, () => new Promise(noop), config)\n    }\n\n    query.setData(updater)\n  }\n\n  function makeQuery({ queryCache, queryKey, queryHash, queryFn, config }) {\n    const initialData =\n      typeof config.initialData === 'function'\n        ? config.initialData()\n        : config.initialData\n\n    const hasInitialData = typeof initialData !== 'undefined'\n\n    const isStale = !config.enabled || !hasInitialData\n\n    const initialStatus = hasInitialData\n      ? statusSuccess\n      : config.enabled\n      ? statusLoading\n      : statusIdle\n\n    let query = {\n      queryKey,\n      queryHash,\n      queryFn,\n      config,\n      instances: [],\n      state: queryReducer(undefined, {\n        type: actionInit,\n        initialStatus,\n        initialData,\n        hasInitialData,\n        isStale,\n      }),\n    }\n\n    query.dispatch = action => {\n      query.state = queryReducer(query.state, action)\n      query.instances.forEach(d => d.onStateUpdate(query.state))\n      notifyGlobalListeners()\n    }\n\n    query.scheduleStaleTimeout = () => {\n      if (isServer) return\n      clearTimeout(query.staleTimeout)\n\n      if (query.config.staleTime === Infinity) {\n        return\n      }\n\n      query.staleTimeout = setTimeout(() => {\n        if (queryCache.getQuery(query.queryKey)) {\n          query.invalidate()\n        }\n      }, query.config.staleTime)\n    }\n\n    query.invalidate = () => {\n      clearTimeout(query.staleTimeout)\n      query.dispatch({ type: actionMarkStale })\n    }\n\n    query.scheduleGarbageCollection = () => {\n      if (query.config.cacheTime === Infinity) {\n        return\n      }\n      query.dispatch({ type: actionMarkGC })\n      query.cacheTimeout = setTimeout(\n        () => {\n          queryCache.removeQueries(\n            d =>\n              d.state.markedForGarbageCollection &&\n              d.queryHash === query.queryHash\n          )\n        },\n        typeof query.state.data === 'undefined' &&\n          query.state.status !== 'error'\n          ? 0\n          : query.config.cacheTime\n      )\n    }\n\n    query.heal = () => {\n      // Stop the query from being garbage collected\n      clearTimeout(query.cacheTimeout)\n\n      // Mark the query as not cancelled\n      query.cancelled = null\n    }\n\n    query.cancel = () => {\n      query.cancelled = cancelledError\n\n      if (query.cancelPromises) {\n        query.cancelPromises()\n      }\n\n      delete query.promise\n    }\n\n    query.clearIntervals = () => {\n      query.instances.forEach(instance => {\n        instance.clearInterval()\n      })\n    }\n\n    query.setState = updater =>\n      query.dispatch({ type: actionSetState, updater })\n\n    query.setData = updater => {\n      // Set data and mark it as cached\n      query.dispatch({ type: actionSuccess, updater })\n\n      // Schedule a fresh invalidation!\n      query.scheduleStaleTimeout()\n    }\n\n    query.clear = () => {\n      clearTimeout(query.staleTimeout)\n      clearTimeout(query.cacheTimeout)\n      clearTimeout(query.retryTimeout)\n      query.clearIntervals()\n      query.cancel()\n      query.dispatch = noop\n      delete queryCache.queries[query.queryHash]\n    }\n\n    query.subscribe = (onStateUpdate = noop) => {\n      const instance = {\n        id: uid(),\n        onStateUpdate,\n      }\n\n      query.instances.push(instance)\n\n      query.heal()\n\n      instance.clearInterval = () => {\n        clearInterval(instance.refetchIntervalId)\n        delete instance.refetchIntervalId\n      }\n\n      instance.updateConfig = config => {\n        const oldConfig = instance.config\n\n        // Update the config\n        instance.config = config\n\n        if (!isServer) {\n          if (oldConfig?.refetchInterval === config.refetchInterval) {\n            return\n          }\n\n          query.clearIntervals()\n\n          const minInterval = Math.min(\n            ...query.instances.map(d => d.config.refetchInterval || Infinity)\n          )\n\n          if (\n            !instance.refetchIntervalId &&\n            minInterval > 0 &&\n            minInterval < Infinity\n          ) {\n            instance.refetchIntervalId = setInterval(() => {\n              if (\n                isDocumentVisible() ||\n                query.instances.some(\n                  instance => instance.config.refetchIntervalInBackground\n                )\n              ) {\n                query.fetch()\n              }\n            }, minInterval)\n          }\n        }\n      }\n\n      instance.run = async () => {\n        try {\n          // Perform the refetch for this query if necessary\n          if (\n            query.config.enabled && // Don't auto refetch if disabled\n            !query.wasSuspended && // Don't double refetch for suspense\n            query.state.isStale && // Only refetch if stale\n            (query.config.refetchOnMount || query.instances.length === 1)\n          ) {\n            await query.fetch()\n          }\n\n          query.wasSuspended = false\n        } catch (error) {\n          Console.error(error)\n        }\n      }\n\n      instance.unsubscribe = () => {\n        query.instances = query.instances.filter(d => d.id !== instance.id)\n\n        if (!query.instances.length) {\n          query.clearIntervals()\n          query.cancel()\n\n          if (!isServer) {\n            // Schedule garbage collection\n            query.scheduleGarbageCollection()\n          }\n        }\n      }\n\n      return instance\n    }\n\n    // Set up the core fetcher function\n    const tryFetchData = async (queryFn, ...args) => {\n      try {\n        // Perform the query\n        const promise = queryFn(...query.config.queryFnParamsFilter(args))\n\n        query.cancelPromises = () => promise.cancel?.()\n\n        const data = await promise\n        delete query.shouldContinueRetryOnFocus\n\n        delete query.cancelPromises\n        if (query.cancelled) throw query.cancelled\n\n        return data\n      } catch (error) {\n        delete query.cancelPromises\n        if (query.cancelled) throw query.cancelled\n\n        // If we fail, increase the failureCount\n        query.dispatch({ type: actionFailed })\n\n        // Do we need to retry the request?\n        if (\n          query.config.retry === true ||\n          query.state.failureCount <= query.config.retry ||\n          (typeof query.config.retry === 'function' &&\n            query.config.retry(query.state.failureCount, error))\n        ) {\n          // Only retry if the document is visible\n          if (!isDocumentVisible()) {\n            // set this flag to continue retries on focus\n            query.shouldContinueRetryOnFocus = true\n            return new Promise(noop)\n          }\n\n          delete query.shouldContinueRetryOnFocus\n\n          // Determine the retryDelay\n          const delay = functionalUpdate(\n            query.config.retryDelay,\n            query.state.failureCount\n          )\n\n          // Return a new promise with the retry\n          return await new Promise((resolve, reject) => {\n            // Keep track of the retry timeout\n            query.retryTimeout = setTimeout(async () => {\n              if (query.cancelled) return reject(query.cancelled)\n\n              try {\n                const data = await tryFetchData(queryFn, ...args)\n                if (query.cancelled) return reject(query.cancelled)\n                resolve(data)\n              } catch (error) {\n                if (query.cancelled) return reject(query.cancelled)\n                reject(error)\n              }\n            }, delay)\n          })\n        }\n\n        throw error\n      }\n    }\n\n    query.fetch = async ({ __queryFn = query.queryFn } = {}) => {\n      // Create a new promise for the query cache if necessary\n      if (!query.promise) {\n        query.promise = (async () => {\n          // If there are any retries pending for this query, kill them\n          query.cancelled = null\n\n          const callbackInstances = [...query.instances]\n\n          if (query.wasSuspended) {\n            callbackInstances.unshift(query.fallbackInstance)\n          }\n\n          try {\n            // Set up the query refreshing state\n            query.dispatch({ type: actionFetch })\n\n            // Try to get the data\n            let data = await tryFetchData(__queryFn, ...query.queryKey)\n\n            query.setData(old =>\n              query.config.isDataEqual(old, data) ? old : data\n            )\n\n            callbackInstances.forEach(\n              instance =>\n                instance.config.onSuccess &&\n                instance.config.onSuccess(query.state.data)\n            )\n\n            callbackInstances.forEach(\n              instance =>\n                instance.config.onSettled &&\n                instance.config.onSettled(query.state.data, null)\n            )\n\n            delete query.promise\n\n            return data\n          } catch (error) {\n            query.dispatch({\n              type: actionError,\n              cancelled: error === query.cancelled,\n              error,\n            })\n\n            delete query.promise\n\n            if (error !== query.cancelled) {\n              callbackInstances.forEach(\n                instance =>\n                  instance.config.onError && instance.config.onError(error)\n              )\n\n              callbackInstances.forEach(\n                instance =>\n                  instance.config.onSettled &&\n                  instance.config.onSettled(undefined, error)\n              )\n\n              throw error\n            }\n          }\n        })()\n      }\n\n      return query.promise\n    }\n\n    return query\n  }\n\n  return queryCache\n}\n\nexport function queryReducer(state, action) {\n  const newState = switchActions(state, action)\n\n  Object.assign(newState, {\n    isLoading: newState.status === statusLoading,\n    isSuccess: newState.status === statusSuccess,\n    isError: newState.status === statusError,\n    isIdle: newState.status === statusIdle,\n  })\n\n  return newState\n}\n\nfunction switchActions(state, action) {\n  switch (action.type) {\n    case actionInit:\n      return {\n        status: action.initialStatus,\n        error: null,\n        isFetching:\n          !action.hasInitialData || action.initialStatus === 'loading',\n        canFetchMore: false,\n        failureCount: 0,\n        isStale: action.isStale,\n        markedForGarbageCollection: false,\n        data: action.initialData,\n        updatedAt: action.hasInitialData ? Date.now() : 0,\n      }\n    case actionFailed:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case actionMarkStale:\n      return {\n        ...state,\n        isStale: true,\n      }\n    case actionMarkGC: {\n      return {\n        ...state,\n        markedForGarbageCollection: true,\n      }\n    }\n    case actionFetch:\n      return {\n        ...state,\n        status:\n          typeof state.data !== 'undefined' ? statusSuccess : statusLoading,\n        isFetching: true,\n        failureCount: 0,\n      }\n    case actionSuccess:\n      return {\n        ...state,\n        status: statusSuccess,\n        data: functionalUpdate(action.updater, state.data),\n        error: null,\n        isStale: false,\n        isFetching: false,\n        canFetchMore: action.canFetchMore,\n        updatedAt: Date.now(),\n        failureCount: 0,\n      }\n    case actionError:\n      return {\n        ...state,\n        isFetching: false,\n        isStale: true,\n        ...(!action.cancelled && {\n          status: statusError,\n          error: action.error,\n        }),\n      }\n    case actionSetState:\n      return functionalUpdate(action.updater, state)\n    default:\n      throw new Error()\n  }\n}\n","import { isOnline, isDocumentVisible, Console, isServer } from './utils'\nimport { queryCaches } from './queryCache'\n\nconst visibilityChangeEvent = 'visibilitychange'\nconst focusEvent = 'focus'\n\nconst onWindowFocus = () => {\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(queryCache =>\n      queryCache\n        .invalidateQueries(query => {\n          if (!query.instances.length) {\n            return false\n          }\n\n          if (!query.config.enabled) {\n            return false\n          }\n\n          if (query.shouldContinueRetryOnFocus) {\n            // delete promise, so refetching will create new one\n            delete query.promise\n            return true\n          }\n\n          return query.config.refetchOnWindowFocus\n        })\n        .catch(Console.error)\n    )\n  }\n}\n\nlet removePreviousHandler\n\nexport function setFocusHandler(callback) {\n  // Unsub the old watcher\n  if (removePreviousHandler) {\n    removePreviousHandler()\n  }\n  // Sub the new watcher\n  removePreviousHandler = callback(onWindowFocus)\n}\n\nsetFocusHandler(handleFocus => {\n  // Listen to visibillitychange and focus\n  if (!isServer && window?.addEventListener) {\n    window.addEventListener(visibilityChangeEvent, handleFocus, false)\n    window.addEventListener(focusEvent, handleFocus, false)\n\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener(visibilityChangeEvent, handleFocus)\n      window.removeEventListener(focusEvent, handleFocus)\n    }\n  }\n})\n","import React from 'react'\n\n//\n\nimport { useQueryCache } from './queryCache'\nimport { useConfigContext } from './config'\nimport { useMountedCallback, Console } from './utils'\n\nexport function useBaseQuery(queryKey, queryFn, config = {}) {\n  // Make a rerender function\n  const rerender = useMountedCallback(React.useState()[1])\n\n  // Build the final config\n  const configContext = useConfigContext()\n\n  config = {\n    ...configContext.shared,\n    ...configContext.queries,\n    ...config,\n  }\n\n  // Get the query cache\n  const queryCache = useQueryCache()\n\n  // Build the query for use\n  const query = queryCache.buildQuery(queryKey, queryFn, config)\n\n  // Create a query instance ref\n  const instanceRef = React.useRef()\n\n  // Subscribe to the query when the subscribe function changes\n  React.useEffect(() => {\n    instanceRef.current = query.subscribe(() => rerender({}))\n\n    // Unsubscribe when things change\n    return instanceRef.current.unsubscribe\n  }, [query, rerender])\n\n  // Always update the config\n  React.useEffect(() => {\n    instanceRef.current.updateConfig(config)\n  })\n\n  // Run the instance when the query or enabled change\n  React.useEffect(() => {\n    if (config.enabled && query) {\n      // Just for change detection\n    }\n    instanceRef.current.run()\n  }, [config.enabled, query])\n\n  const refetch = React.useCallback(async () => {\n    try {\n      await query.fetch()\n    } catch (error) {\n      Console.error(error)\n    }\n  }, [query])\n\n  return {\n    query,\n    refetch,\n    ...query.state,\n  }\n}\n","import { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, handleSuspense } from './utils'\n\nexport function useQuery(...args) {\n  const query = useBaseQuery(...getQueryArgs(args))\n\n  handleSuspense(query)\n\n  return query\n}\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n"],"sourceRoot":""}